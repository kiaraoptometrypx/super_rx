<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ultimate Calculator</title>
<style>

th.red, td.red {
  background: #F5EFED;
  color: black;
}
th.yellow, td.yellow {
  background: #FFFEF2;
  color: black;
}
th.blue, td.blue {
  background: #F2FFFA;
  color: black;
}

/* Column 1: width 25% */
td:nth-child(1),
th:nth-child(1) {
  width: 22%;
}

/* Column 2: width 25% + remove RIGHT border */
td:nth-child(2),
th:nth-child(2) {
  width: 26%;
}

/* Column 3: width 25% + remove LEFT & RIGHT borders */
td:nth-child(3),
th:nth-child(3) {
  width: 26%;
}

/* Column 4: width 25% + remove LEFT border */
td:nth-child(4),
th:nth-child(4) {
  width: 26%;
}


.hidden-row {
  opacity: 0.05;       /* semi-transparent */
  pointer-events: none; /* optional: disable interactions */
}

  body {
    font-family: 'Manrope', sans-serif;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  table {
    border-collapse: collapse;
    width: 100%;
    max-width: 550px;
    min-width: 550px;
    margin-top: 20px;
    text-align: center;
    margin-right: 20px;
    margin-left: 20px;
  }

  th, td {
    border: 1px solid #aaa;
    padding: 10px 14px;
    text-align: center;
  }

  th {
    background: #eee;
    font-weight: 600;
  }

  input {
    width: 70px;
    text-align: center;
    padding: 4px 6px;
    border: 1px solid lightgrey;
    border-radius:6px;
  }
body, table, th, td, input, button {
  font-size: 11px;
}
</style>

</head>
<body>
<div>
<h2>Superposition Refraction</h2>

<table>
  
<tr><th class="red" colspan="4">Current RX</th></tr>

<!-- OD -->

<tr>
  <td>Right</td>
  <td>Sph : <input type="number" step="0.25" id="od_origS"></td>
  <td>Cyl : <input type="number" step="0.25" id="od_origC"></td>
  <td>Ax : <input type="number" step="5" min="0" max="180" id="od_origA"></td>
</tr>
<tr>
  <td>Left</td>
  <td>Sph : <input type="number" step="0.25" id="os_origS"></td>
  <td>Cyl : <input type="number" step="0.25" id="os_origC"></td>
  <td>Ax : <input type="number" step="5" min="0" max="180" id="os_origA"></td>
</tr>


<tr><th class="red" colspan="4"></th></tr>

</table>
<table>




<!-- Vector Refraction -->
<tr>
  <th class="yellow" colspan="4">Vector Refraction</th></tr>
<tr>
  <td>FC DC Bal BE<br><div style="margin-top:5px"><button onclick="copyVD_OU_to_ODOS()" style="border-radius:10px; width:70px; height:25px">Export</button></div></td>
  <td>
     Sph : <input type="number" step="0.25" id="vd_ouS"><br>
    <div style="margin-top:10px"><span id="vd_out_ouS">-</span></div>
  </td>
  <td>
    Cyl : <input type="number" step="0.25" id="vd_ouC"><br>
    <div style="margin-top:10px"><span id="vd_out_ouC">-</span></div>
  </td>
  <td>
    Ax : <input type="number" step="5" min="0" max="180" id="vd_ouA"><br>
    <div style="margin-top:10px"><span id="vd_out_ouA">-</span></div>
  </td>
</tr>

<tr>
  <td>FC DC Bal R<br><div style="margin-top:5px"><button onclick="copyVD_OD()" style="border-radius:10px; width:70px; height:25px">Export</button></div></td>
  <td>
     Sph : <input type="number" step="0.25" id="vd_odS"><br>
    <div style="margin-top:10px"><span id="vd_out_odS">-</span></div>
  </td>
  <td>
    Cyl : <input type="number" step="0.25" id="vd_odC"><br>
    <div style="margin-top:10px"><span id="vd_out_odC">-</span></div>
  </td>
  <td>
    Ax : <input type="number" step="5" min="0" max="180" id="vd_odA"><br>
    <div style="margin-top:10px"><span id="vd_out_odA">-</span></div>
  </td>
</tr>

<tr>
  <td>FC DC Bal L<br>
    <div style="margin-top:5px">
      <button onclick="copyVD_OS()" style="border-radius:10px; width:70px; height:25px">Export</button>
    </div>
  </td>
  <td>
    Sph : <input type="number" step="0.25" id="vd_osS"><br>
    <div style="margin-top:10px"><span id="vd_out_osS">-</span></div>
  </td>
  <td>
    Cyl : <input type="number" step="0.25" id="vd_osC"><br>
    <div style="margin-top:10px"><span id="vd_out_osC">-</span></div>
  </td>
  <td>
    Ax : <input type="number" step="5" min="0" max="180" id="vd_osA"><br>
    <div style="margin-top:10px"><span id="vd_out_osA">-</span></div>
  </td>

</tr>
<tr>
  <td>R Dx</td>
  <td><input type="number" step="0.25" id="vc_odS"></td>
  <td><input type="number" step="0.25" id="vc_odC"></td>
  <td><input type="number" step="5" min="0" max="180" id="vc_odA"></td>
</tr>
<tr>
  <td>L Dx</td>
  <td><input type="number" step="0.25" id="vc_osS"></td>
  <td><input type="number" step="0.25" id="vc_osC"></td>
  <td><input type="number" step="5" min="0" max="180" id="vc_osA"></td>
</tr>
<tr >
  <td>Bino Dx</td>
  <td id="vc_crossS">-</td>
  <td id="vc_crossC">-</td>
  <td id="vc_crossA">-</td>
</tr>

<tr>
  <td>Right</td>
  <td>Sph : <span id="od_vcFinalS">0.00</span></td>
  <td>Cyl : <span id="od_vcFinalC">0.00</span></td>
  <td>Ax : <span id="od_vcFinalA">-</span></td>
</tr>

<tr>
  <td>Left</td>
  <td>Sph : <span id="os_vcFinalS">0.00</span></td>
  <td>Cyl : <span id="os_vcFinalC">0.00</span></td>
  <td>Ax : <span id="os_vcFinalA">-</span></td>
</tr>



<tr><th class="yellow" colspan="4">Status : <select id="statusVector" style="font-size:11px; border-radius:6px; height:20px; margin-left:10px">
  <option value="notdone">Not Done</option>
  <option value="done">Done</option>
</select></th>

</table>
<table>

<!-- Manual Subjective Refraction -->
<tr><th class="blue" colspan="4">

Manual Refraction
<button style="margin-left:20px; background-color:#F2FFFA; border-radius:10px; height:25px; width:150px" id="toggleMask1">Hide/Show Manual</button>

</th></tr>

<tr class="mask1">
  <td>R Dx</td>
  <td id="od_roundS"></td>
  <td id="od_roundC"></td>
  <td id="od_roundA"></td>
</tr>

<tr class="mask1">
  <td>L Dx</td>
  <td id="os_roundS"></td>
  <td id="os_roundC"></td>
  <td id="os_roundA"></td>
</tr>
<tr class="mask1">
  <td>Bino Dx</td>
  <td id="diffCrossS"></td>
  <td id="diffCrossC"></td>
  <td id="diffCrossA"></td>
</tr>



<tr class="mask1">
  <td>Right</td>
  <td>Sph : <input type="number" step="0.25" id="od_finalS"></td>
  <td>Cyl : <input type="number" step="0.25" id="od_finalC"></td>
  <td>Ax : <input type="number" step="5" min="0" max="180" id="od_finalA"></td>
</tr>
<tr class="mask1">
  <td>Left</td>
  <td>Sph : <input type="number" step="0.25" id="os_finalS"></td>
  <td>Cyl : <input type="number" step="0.25" id="os_finalC"></td>
  <td>Ax : <input type="number" step="5" min="0" max="180" id="os_finalA"></td>
</tr>

<tr style="display:none" class="mask1">
  <td colspan="1">Crossed OD</td>
  <td id="od_crossS"></td>
  <td id="od_crossC"></td>
  <td id="od_crossA"></td>
</tr>
<tr style="display:none" class="mask1">
  <td colspan="1">Crossed OS</td>
  <td id="os_crossS"></td>
  <td id="os_crossC"></td>
  <td id="os_crossA"></td>
</tr>


<th class="blue" colspan="4">Status : <select id="statusManual" style="font-size:11px; border-radius:6px; height:20px; margin-left:10px">
  <option value="notdone">Not Done</option>
  <option value="done">Done</option>
</select></th>

</table>


</div>

<div style="height:-20px"></div>



<div id="captureTarget">

<table>

<tr style="border:none;">
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
  <td style="border:none;"></td>
</tr>

<tr class="mask3" style="border:none;"> 
  <td colspan="4" style="border:none;">
    Gaze Angle: 
    <input type="range" id="gazeAngle" step="5" value="35" min="10" max="50" oninput="this.nextElementSibling.value = this.value">
    <output>35</output>

    <span style="display:inline-block; width:65px;"></span> <!-- gap -->

    BVD (mm): 
    <input type="range" id="vertexDist" step="1" value="12" min="1" max="20" oninput="this.nextElementSibling.value = this.value">
    <output>14</output>
  </td>
</tr>


<tr><th colspan="4" >Summary <button style="margin-left:20px; border-radius:10px; height:25px; width:170px" id="toggleMask3">Hide/Show Gaze/BVD</button>
</th></tr>
<tr>
<td colspan="2" style="border-right:none;">Name : <input type="text" id="customerName" style="width:65%; height:20px"></td>
<td colspan="2" style="border-left:none;">Whatsapp : <input type="text" id="customerWhatsapp" style="width:65%; height:20px"></td>

</tr>
<tr>

<td colspan="3" style="border-right:none; vertical-align:middle;">
  Notes :
  <textarea id="notes" style="width:79%; border-radius:5px; border:1px solid lightgrey; height:40px; vertical-align:middle;"></textarea>
</td>


<td style="border-left:none" colspan="1">
<button style="border-radius:10px; height:25px; width:100px" id="sendWhatsappBtn">Send WA</button>

<br><br>

<button style="border-radius:10px; height:25px; width:100px"  onclick="capturePart()">Save JPG</button>
</td>
</tr>


<tr>
  <td class="red">Current Rx</td>
  <td colspan="3" class="red">

    R: <span id="od_origCombined" style="margin-right: 100px;">OD -</span>
    L: <span id="os_origCombined">OS -</span>
  </td>
</tr>

<tr>
  <td class="red">Current Gaze</td>
  <td class="red" colspan="3">
    Horizontal : <span id="origCrossS" style="margin-right: 50px;">-</span>
    Vertical : <span id="origCrossC" style="margin-right: 50px;">-</span>
    Diagonal : <span id="origCrossA">-</span>
  </td>
</tr>

<tr>
  <td class="yellow">Vector Rx</td>
  <td class="yellow" colspan="3">
    R : <span id="od_vcCombined" style="margin-right: 100px;">-</span>
    L : <span id="os_vcCombined">-</span>
  </td>
</tr>
<tr>
  <td class="yellow">FC DC Bal</td>
  <td colspan="3" class="yellow">
   BE : <span id="vd_ouSummary">-</span><br><br>
    R : <span id="vd_odSummary" style="margin-right: 30px;">-</span>
    L : <span id="vd_osSummary">-</span>
  </td>
</tr>
<tr>
  <td class="yellow">RX Changes</td>
  <td colspan="3" class="yellow">
    R: <span id="vc_odSummary" style="margin-right: 100px;">-</span>
    L: <span id="vc_osSummary">-</span>
  </td>
</tr>


<tr>
  <td class="yellow">Gaze Changes</td>
  <td class="yellow" colspan="3">
    Horizontal : <span id="prismH_vc" style="margin-right: 50px;">-</span>
    Vertical : <span id="prismV_vc" style="margin-right: 50px;">-</span>
    Diagonal : <span id="prismD_vc">-</span>
  </td>
</tr>




<tr class="mask1">
  <td class="blue">Manual Rx</td>
  <td class="blue" colspan="3">
    R : <span id="od_finalCombined" style="margin-right: 100px;">OD -</span>
    L : <span id="os_finalCombined">OS -</span>
  </td>
</tr>

<tr class="mask1">
  <td class="blue">RX Changes</td>
  <td colspan="3" class="blue">
    R: <span id="od_roundCombinedDisplay" style="margin-right: 100px;">-</span>
    L: <span id="os_roundCombinedDisplay">-</span>
  </td>
</tr>

<tr class="mask1">
  <td class="blue">Gaze Changes</td>
  <td class="blue" colspan="3">
    Horizontal : <span id="prismH" style="margin-right: 50px;">-</span>
    Vertical : <span id="prismV" style="margin-right: 50px;">-</span>
    Diagonal : <span id="prismD">-</span>
  </td>
</tr>




<tr><td colspan="4"><span style="display:block;"> Gaze Adaptability  
  <span style="color:green;">Green = Tolerable</span>,
  <span style="color:purple;">Purple = Borderline</span>,
  <span style="color:red;">Red = Risky</span>
</span>
</td></tr>
<tr><td colspan="4">
<button style="margin-left:20px; background-color:#F2FFFA; border-radius:10px; height:25px; width:150px" id="toggleMask1_copy">Hide/Show Manual</button>
</td></tr>


<tr style="height:25px"></tr>
<tr><th colspan="4">Near Vision <button style="margin-left:20px; border-radius:10px; height:25px; width:120px" id="toggleMask2">Hide/Show Add</button></th></tr>



<tr class="mask2">
  <td class="red">Current </td>
  <td class="red" colspan="3"><input style="margin-right:30px; width:55px" type="number" step="0.25" min="0" max="5" id="nearAdd" placeholder="">

    R: <span id="od_nearCombined" style="margin-right: 50px;">0.00 / 0.00 x 0</span>
    L: <span id="os_nearCombined">0.00 / 0.00 x 0</span>
  </td>
</tr>

<tr class="mask2">
  <td class="yellow">Vector</td>
  <td class="yellow" colspan="3"><input style="margin-right:30px; width:55px" type="number" step="0.25" min="0" max="5" id="nearAddVector" placeholder="">
    R: <span id="od_vcNearCombined" style="margin-right: 50px;">0.00 / 0.00 x 0</span>
    L: <span id="os_vcNearCombined">0.00 / 0.00 x 0</span>
  </td>
</tr>

<tr class="mask2">
  <td class="blue">Manual</td>
  <td class="blue" colspan="3"><input style="margin-right:30px; width:55px" type="number" step="0.25" min="0" max="5" id="nearAddFinal" placeholder="">
    R: <span id="od_finalNearCombined" style="margin-right: 50px;">0.00 / 0.00 × 0</span>
    L: <span id="os_finalNearCombined">0.00 / 0.00 × 0</span>
  </td>
</tr>

<tr><th colspan="4"></th></tr>



</table>
<div style="margin-top:10px; margin-left:20px">
<div>End of Results</div></div>
<div style="height:10px"></div>

</div>


<div style="text-align:left; margin-top:10px;">
  <div style="height:10px"></div>
  <div>
    <button style="width:150px; height:25px" onclick="exportInputs()">Export Inputs</button>
    <textarea id="rxExportBox" style="width:95%;height:150px;margin-top:10px;"></textarea>
  </div>
  <div style="height:30px"></div>
</div>


<div style="height:350px"></div>


<script>
// Export inputs as CSV and open Gmail
function exportInputs() {
  const out = ["RX_EXPORT_INPUTS_V1"];

  // inputs
  document.querySelectorAll("input[id]").forEach(el => {
    out.push(`${el.id}=${el.value}`);
  });

  // statuses (selects)
  ["statusVector", "statusManual"].forEach(id => {
    const el = document.getElementById(id);
    if (el) out.push(`${id}=${el.options[el.selectedIndex].text}`);
  });


  // CSV-style text
  const csvText = out.join(", ");
  document.getElementById("rxExportBox").value = csvText;

  // Separator
  const separator = "--------------------------";

  // Human-readable summary EXACTLY as you specified
  const summaryText = 
`CURRENT:
RX R/L:     ${document.getElementById("od_origCombined")?.textContent || "-"}     //     ${document.getElementById("os_origCombined")?.textContent || "-"}  
Gaze Imbalance:     Horizontal: ${document.getElementById("origCrossS")?.textContent || "-"}     //     Vertical: ${document.getElementById("origCrossC")?.textContent || "-"}     //     Diagonal: ${document.getElementById("origCrossA")?.textContent || "-"}  
ADD:     ${document.getElementById("nearAdd")?.value || "0.00"} 

VECTOR (${document.getElementById("statusVector")?.options[document.getElementById("statusVector").selectedIndex]?.text || "-"}):
RX R/L:     ${document.getElementById("od_vcCombined")?.textContent || "-"}     //     ${document.getElementById("os_vcCombined")?.textContent || "-"}  
Gaze Imbalance:     Horizontal: ${document.getElementById("prismH_vc")?.textContent || "-"}     //     Vertical  ${document.getElementById("prismV_vc")?.textContent || "-"}     //     Diagonal: ${document.getElementById("prismD_vc")?.textContent || "-"}  
ADD:     ${document.getElementById("nearAddVector")?.value || "0.00"}   
FC DC Bal Both Eye:     ${document.getElementById("vd_ouSummary")?.textContent || "-"}  
FC DC BAL R/L:     ${document.getElementById("vd_odSummary")?.textContent || "-"}     //     ${document.getElementById("vd_osSummary")?.textContent || "-"}  
RX Changes R/L:          ${document.getElementById("vc_odSummary")?.textContent || "-"}     //     ${document.getElementById("vc_osSummary")?.textContent || "-"}  

MANUAL (${document.getElementById("statusManual")?.options[document.getElementById("statusManual").selectedIndex]?.text || "-"}):
RX R/L:     ${document.getElementById("od_finalCombined")?.textContent || "-"}     //     ${document.getElementById("os_finalCombined")?.textContent || "-"}  
Gaze Imbalance:     Horizontal: ${document.getElementById("prismH")?.textContent || "-"}     //     Vertical: ${document.getElementById("prismV")?.textContent || "-"}     //     Diagonal: ${document.getElementById("prismD")?.textContent || "-"}  
ADD:     ${document.getElementById("nearAddFinal")?.value || "0.00"}
RX Changes R/L:     R: ${document.getElementById("od_roundCombinedDisplay")?.textContent || "-"}     //     ${document.getElementById("os_roundCombinedDisplay")?.textContent || "-"}  
`;

  // Combine CSV + separator + summary
  const emailBody = csvText + "\n\n" + separator + "\n\n" + summaryText;

  // Prepare Gmail
  const customerNameInput = document.getElementById("customerName");
  const whatsappNumberInput = document.getElementById("whatsappNumber");
  const customerName = customerNameInput?.value.trim() || "Unnamed";
  const whatsappNumber = whatsappNumberInput?.value.trim() || "";

  const recipient = "kiara.optometry.px@gmail.com";
  const subject = encodeURIComponent(`${customerName}${whatsappNumber ? " - " + whatsappNumber : ""}`);
  const body = encodeURIComponent(emailBody);

  // Open Gmail compose
  const gmailUrl = `https://mail.google.com/mail/?view=cm&fs=1&to=${recipient}&su=${subject}&body=${body}`;
  window.open(gmailUrl, "_blank");
}

// Paste listener to restore inputs from CSV
document.addEventListener("paste", e => {
  const text = e.clipboardData.getData("text").trim();
  if (!text.startsWith("RX_EXPORT_INPUTS_V1")) return;

  e.preventDefault();
  const parts = text.split(",").slice(1);

  parts.forEach(part => {
    const eq = part.indexOf("=");
    if (eq === -1) return;

    const id = part.slice(0, eq).trim();
    const val = part.slice(eq + 1).trim();

    const el = document.getElementById(id);
    if (!el) return;

    if (el.tagName === "INPUT") {
      if (el.type === "number") {
        el.value = parseFloat(val) || "";
      } else {
        el.value = val;
      }
    } else if (el.tagName === "SELECT") {
      // Restore select by matching option text
      const option = Array.from(el.options).find(o => o.text === val);
      if (option) el.value = option.value;
    }

    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
  });
});

</script>






<script>
["nearAdd", "nearAddVector", "nearAddFinal"].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener("input", () => {
    let val = parseFloat(el.value);
    if (isNaN(val)) return;
    el.value = (Math.round(val * 4) / 4).toFixed(2);
  });
});
</script>











<SCRIPT>



window.addEventListener("DOMContentLoaded", () => {
  const addInput = document.getElementById("nearAddFinal");

  function updateFinalNearRx() {
    const add = parseFloat(addInput.value) || 0;

    // Get subjective Rx values
    const odS = parseFloat(document.getElementById("od_finalS").value) || 0;
    const odC = parseFloat(document.getElementById("od_finalC").value) || 0;
    const odA = parseInt(document.getElementById("od_finalA").value) || 0;

    const osS = parseFloat(document.getElementById("os_finalS").value) || 0;
    const osC = parseFloat(document.getElementById("os_finalC").value) || 0;
    const osA = parseInt(document.getElementById("os_finalA").value) || 0;

    // Near sphere = subjective Sph + Add
    let odNearS = odS + add;
    let osNearS = osS + add;

    // Format with plus sign if positive
    odNearS = (odNearS > 0 ? "+" : "") + odNearS.toFixed(2);
    osNearS = (osNearS > 0 ? "+" : "") + osNearS.toFixed(2);

    // Update spans
    document.getElementById("od_finalNearCombined").textContent = `${odNearS} / ${odC.toFixed(2)} × ${odA}`;
    document.getElementById("os_finalNearCombined").textContent = `${osNearS} / ${osC.toFixed(2)} × ${osA}`;
  }

  // Update whenever Add changes
  addInput.addEventListener("input", updateFinalNearRx);

  // Update live whenever subjective Rx changes
  ["od_finalS","od_finalC","od_finalA","os_finalS","os_finalC","os_finalA"].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", updateFinalNearRx);
  });

  // Initial update
  updateFinalNearRx();
});


window.addEventListener("DOMContentLoaded", () => {
  const addInput = document.getElementById("nearAdd");

  function updateNearRx() {
    const add = parseFloat(addInput.value) || 0;

    // Get distance Rx values
    const odS = parseFloat(document.getElementById("od_origS").value) || 0;
    const odC = parseFloat(document.getElementById("od_origC").value) || 0;
    const odA = parseInt(document.getElementById("od_origA").value) || 0;

    const osS = parseFloat(document.getElementById("os_origS").value) || 0;
    const osC = parseFloat(document.getElementById("os_origC").value) || 0;
    const osA = parseInt(document.getElementById("os_origA").value) || 0;

    // Near sphere = distance Sph + Add
    let odNearS = odS + add;
    let osNearS = osS + add;

    // Format sphere with plus sign if positive
    odNearS = (odNearS > 0 ? "+" : "") + odNearS.toFixed(2);
    osNearS = (osNearS > 0 ? "+" : "") + osNearS.toFixed(2);

    // Update spans
    document.getElementById("od_nearCombined").textContent = `${odNearS} / ${odC.toFixed(2)} × ${odA}`;
    document.getElementById("os_nearCombined").textContent = `${osNearS} / ${osC.toFixed(2)} × ${osA}`;
  }

  // Update whenever Add changes
  addInput.addEventListener("input", updateNearRx);

  // Update whenever distance Rx changes
  ["od_origS","od_origC","od_origA","os_origS","os_origC","os_origA"].forEach(id => {
    const el = document.getElementById(id);
    if(el) el.addEventListener("input", updateNearRx);
  });
});


window.addEventListener("DOMContentLoaded", () => {
  const addInput = document.getElementById("nearAddVector");

  function updateVcNearRx() {
    const add = parseFloat(addInput.value) || 0;

    // Get far vector Rx values
    const odS = parseFloat(document.getElementById("od_vcFinalS").textContent) || 0;
    const odC = parseFloat(document.getElementById("od_vcFinalC").textContent) || 0;
    const odA = parseInt(document.getElementById("od_vcFinalA").textContent) || 0;

    const osS = parseFloat(document.getElementById("os_vcFinalS").textContent) || 0;
    const osC = parseFloat(document.getElementById("os_vcFinalC").textContent) || 0;
    const osA = parseInt(document.getElementById("os_vcFinalA").textContent) || 0;

    // Near sphere = far Sph + Add
    let odNearS = odS + add;
    let osNearS = osS + add;

    // Format with plus sign if positive
    odNearS = (odNearS > 0 ? "+" : "") + odNearS.toFixed(2);
    osNearS = (osNearS > 0 ? "+" : "") + osNearS.toFixed(2);

    // Update spans
    document.getElementById("od_vcNearCombined").textContent = `${odNearS} / ${odC.toFixed(2)} × ${odA}`;
    document.getElementById("os_vcNearCombined").textContent = `${osNearS} / ${osC.toFixed(2)} × ${osA}`;
  }

  // Update on Add input change
  addInput.addEventListener("input", updateVcNearRx);

  // Live update when far vector Rx changes
  ["od_vcFinalS","od_vcFinalC","od_vcFinalA","os_vcFinalS","os_vcFinalC","os_vcFinalA"].forEach(id => {
    const el = document.getElementById(id);
    if(el) {
      // Observe textContent changes for live update
      const observer = new MutationObserver(updateVcNearRx);
      observer.observe(el, { characterData: true, childList: true, subtree: true });
    }
  });

  // Initial update
  updateVcNearRx();
});






function fmtAxis(a){
  if(a === 0 || a === "0") return 180;
  return a;
}


function calcVD(side) {
  const S = Number(document.getElementById(`vd_${side}S`).value) || 0;
  const C = Number(document.getElementById(`vd_${side}C`).value) || 0;
  const A = Number(document.getElementById(`vd_${side}A`).value) || 0;

  const sphAdj = -(C / 2);
  const outS = S + sphAdj;
  const outC = C;
  const outA = A;

  const fmt = v => (v > 0 ? "+" : "") + v.toFixed(2);

  document.getElementById(`vd_out_${side}S`).textContent = fmt(outS);
  document.getElementById(`vd_out_${side}C`).textContent = fmt(outC);
  document.getElementById(`vd_out_${side}A`).textContent = outA;
}


["od","os","ou"].forEach(side => {
  ["S","C","A"].forEach(f => {
    const el = document.getElementById(`vd_${side}${f}`);
    if(el) el.addEventListener("input", () => calcVD(side));
  });
});

</script>



<script>
/* ===== Utilities ===== */
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

function normalizeMinus(lens){
  let S = Number(lens.S), C = Number(lens.C), A = Number(lens.A);
  if (isNaN(S)) S = 0; if (isNaN(C)) C = 0; if (isNaN(A)) A = 0;
  if (C > 0){ S += C; C = -C; A = (A + 90) % 180; }
  A = ((A % 180) + 180) % 180;
  return { S: +S, C: +C, A: Math.round(A) % 180 };
}
function toFixed2Num(v){ return +Number(v).toFixed(2); }
function minusToPlus(lens){
  const m = normalizeMinus(lens);
  return { S: toFixed2Num(m.S + m.C), C: toFixed2Num(-m.C), A: Math.round((m.A + 90) % 180) };
}
function roundQuarter(v){
  if(isNaN(v)) return "-";
  const r = Math.round(v / 0.25) * 0.25;
  return (r > 0 ? "+" : "") + r.toFixed(2);
}

function fmtPlus(v){
  const n = Number(v);
  if (isNaN(n)) return "-";
  return (n > 0 ? "+" : "") + n.toFixed(2);
}


function calcDecentration(angleDeg, vertexMM){ return (vertexMM / 10) * Math.tan(angleDeg * Math.PI/180); }

/* ===== Vector & lens math (unchanged) ===== */
function calcBackwardsLens(orig, final){
  const rx1 = normalizeMinus(orig), rxF = normalizeMinus(final);
  const M1 = rx1.S + rx1.C/2;
  const J01 = -rx1.C/2 * Math.cos(2 * deg2rad(rx1.A));
  const J451 = -rx1.C/2 * Math.sin(2 * deg2rad(rx1.A));
  const MF = rxF.S + rxF.C/2;
  const J0F = -rxF.C/2 * Math.cos(2 * deg2rad(rxF.A));
  const J45F = -rxF.C/2 * Math.sin(2 * deg2rad(rxF.A));
  const Mx = MF - M1;
  const J0x = J0F - J01;
  const J45x = J45F - J451;
  const Cx = -2 * Math.sqrt(J0x*J0x + J45x*J45x);
  const Sx = Mx - Cx/2;
  let Ax = 0.5 * rad2deg(Math.atan2(J45x, J0x)); if (Ax < 0) Ax += 180;
  return { S: toFixed2Num(Sx), C: toFixed2Num(Cx), A: Math.round(Ax) % 180 };
}
function pickClosestSphere(candidates){
  const normalized = candidates.map(c => normalizeMinus(c));
  let best = normalized[0];
  for(const c of normalized){ if(Math.abs(c.S) < Math.abs(best.S)) best = c; }
  best.S = toFixed2Num(best.S); best.C = toFixed2Num(best.C); best.A = Math.round(best.A) % 180;
  return best;
}
function bestSingleLens(lens){
  const form1 = { S: lens.S, C: lens.C, A: lens.A };
  const form2 = { S: lens.S + lens.C, C: -lens.C, A: (lens.A + 90) % 180 };
  return pickClosestSphere([form1, form2]);
}
function chooseBestDiff(diff1, diff2){
  const forms = l => [{S:l.S,C:l.C,A:l.A},{S:l.S+l.C,C:-l.C,A:(l.A+90)%180}];
  return pickClosestSphere([...forms(diff1), ...forms(diff2)]);
}
function reverseVectorChange(orig, vector){
  const rxOrig = normalizeMinus(orig), rxVec = normalizeMinus(vector);
  const M1 = rxOrig.S + rxOrig.C/2;
  const J01 = -rxOrig.C/2 * Math.cos(2*deg2rad(rxOrig.A));
  const J451 = -rxOrig.C/2 * Math.sin(2*deg2rad(rxOrig.A));
  const Mx = rxVec.S + rxVec.C/2;
  const J0x = -rxVec.C/2 * Math.cos(2*deg2rad(rxVec.A));
  const J45x = -rxVec.C/2 * Math.sin(2*deg2rad(rxVec.A));
  const MF = M1 + Mx;
  const J0F = J01 + J0x;
  const J45F = J451 + J45x;
  const CF = -2 * Math.sqrt(J0F*J0F + J45F*J45F);
  const SF = MF - CF/2;
  let AF = 0.5 * rad2deg(Math.atan2(J45F, J0F)); if (AF < 0) AF += 180;
  return bestSingleLens({ S: toFixed2Num(SF), C: toFixed2Num(CF), A: Math.round(AF) % 180 });
}

/* ===== Prism color helper, type-specific (percentage-based) ===== */
function colorPrism(el, value, type){
  if(!el) return;

// thresholds for percentage (adjustable)
const thresholds = {
  H: [0.3, 0.5],
  V: [0.1, 0.2],
  D: [0.15, 0.3]
};

// get original prism value
let origId;
if(type === "H") origId = "origCrossS";
else if(type === "V") origId = "origCrossC";
else if(type === "D") origId = "origCrossA";

const origText = document.getElementById(origId)?.textContent || "0";
const origVal = Number(origText) || 0;
const newVal  = Number(value) || 0;

// ===== SPECIAL ZERO RULE =====
if (origVal === 0) {
  if (newVal === 0) {
    el.style.color = "green";  // 0 ÷ 0
    return;
  } else {
    el.style.color = "red";    // anything ÷ 0
    return;
  }
}

// ===== STANDARD PERCENTAGE LOGIC =====
let pct = Math.abs(newVal) / Math.abs(origVal);

// force >100% to red
if (pct > 1) pct = 999;

// assign color
if (pct <= thresholds[type][0]) el.style.color = "green";
else if (pct <= thresholds[type][1]) el.style.color = "purple";
else el.style.color = "red";
}


/* ===== Main update function (integrated, robust) ===== */
function updateCrossedLens(){
  // read inputs (safe fallback 0)
  const odOrig = { S:+document.getElementById('od_origS')?.value || 0, C:+document.getElementById('od_origC')?.value || 0, A:+document.getElementById('od_origA')?.value || 0 };
  const odFinal = { S:+document.getElementById('od_finalS')?.value || 0, C:+document.getElementById('od_finalC')?.value || 0, A:+document.getElementById('od_finalA')?.value || 0 };
  const osOrig = { S:+document.getElementById('os_origS')?.value || 0, C:+document.getElementById('os_origC')?.value || 0, A:+document.getElementById('os_origA')?.value || 0 };
  const osFinal = { S:+document.getElementById('os_finalS')?.value || 0, C:+document.getElementById('os_finalC')?.value || 0, A:+document.getElementById('os_finalA')?.value || 0 };

  // cross calculations (same as before)
  const odCross = bestSingleLens(calcBackwardsLens(odOrig, odFinal));
  const odPlus = minusToPlus(odCross);
  const osCross = bestSingleLens(calcBackwardsLens(osOrig, osFinal));
  const osPlus = minusToPlus(osCross);

  // safe element writes (only if elements exist)
  const setIf = (id, val)=> { const el = document.getElementById(id); if(el) el.textContent = val; };
  setIf('od_crossS', odCross.S);
  setIf('od_crossC', odCross.C);
setIf('od_crossA', fmtAxis(odCross.A));
  setIf('od_roundS', roundQuarter(odPlus.S));
  setIf('od_roundC', roundQuarter(odPlus.C));
setIf('od_roundA', fmtAxis(odPlus.A));

  setIf('os_crossS', osCross.S);
  setIf('os_crossC', osCross.C);
setIf('os_crossA', fmtAxis(osCross.A));
  setIf('os_roundS', roundQuarter(osPlus.S));
  setIf('os_roundC', roundQuarter(osPlus.C));
setIf('os_roundA', fmtAxis(osPlus.A));

  const bestDiff = chooseBestDiff(calcBackwardsLens(osCross, odCross), calcBackwardsLens(odCross, osCross));
  const bestDiffPlus = minusToPlus(bestDiff);

  setIf('diffCrossS', roundQuarter(bestDiffPlus.S));
  setIf('diffCrossC', roundQuarter(bestDiffPlus.C));
setIf('diffCrossA', fmtAxis(bestDiffPlus.A));

  // decentration (used by prism calculation)
  const gaze = +document.getElementById("gazeAngle")?.value || 30;
  const vertex = +document.getElementById("vertexDist")?.value || 12;
  const dec = calcDecentration(gaze, vertex);

  // prism from bestDiff vector
  const A_rad = deg2rad(bestDiff.A);
  const M = bestDiff.S + bestDiff.C/2;
  const J0 = -bestDiff.C/2 * Math.cos(2 * A_rad);
  const J45 = -bestDiff.C/2 * Math.sin(2 * A_rad);

  const prismH = Math.abs((M + J0) * dec);
  const prismV = Math.abs((M - J0) * dec);
  const prism45 = Math.abs((M - J45) * dec);
  const prism135 = Math.abs((M + J45) * dec);
  const prismD = Math.max(prism45, prism135);

  // write and color main prism outputs
  const elH = document.getElementById("prismH");
  const elV = document.getElementById("prismV");
  const elD = document.getElementById("prismD");
  if(elH){ elH.textContent = prismH.toFixed(2); colorPrism(elH, prismH, "H"); }
  if(elV){ elV.textContent = prismV.toFixed(2); colorPrism(elV, prismV, "V"); }
  if(elD){ elD.textContent = prismD.toFixed(2); colorPrism(elD, prismD, "D"); }

  // VC prism section (if vc_cross elements exist we parse them safely)
  const vc_crossS_text = document.getElementById("vc_crossS")?.textContent;
  const vc_crossC_text = document.getElementById("vc_crossC")?.textContent;
  const vc_crossA_text = document.getElementById("vc_crossA")?.textContent;
  // parseFloat returns NaN for "-", fallback to 0
  const vcS = Number.parseFloat(vc_crossS_text) || 0;
  const vcC = Number.parseFloat(vc_crossC_text) || 0;
  const vcA = Number.parseFloat(vc_crossA_text) || 0;
  const A_vc_rad = deg2rad(vcA);
  const M_vc = vcS + vcC/2;
  const J0_vc = -vcC/2 * Math.cos(2 * A_vc_rad);
  const J45_vc = -vcC/2 * Math.sin(2 * A_vc_rad);
  const prismH_vc = Math.abs((M_vc + J0_vc) * dec);
  const prismV_vc = Math.abs((M_vc - J0_vc) * dec);
  const prism45_vc = Math.abs((M_vc - J45_vc) * dec);
  const prism135_vc = Math.abs((M_vc + J45_vc) * dec);
  const prismD_vc = Math.max(prism45_vc, prism135_vc);

  const elH_vc = document.getElementById("prismH_vc");
  const elV_vc = document.getElementById("prismV_vc");
  const elD_vc = document.getElementById("prismD_vc");
  if(elH_vc){ elH_vc.textContent = prismH_vc.toFixed(2); colorPrism(elH_vc, prismH_vc, "H"); }
  if(elV_vc){ elV_vc.textContent = prismV_vc.toFixed(2); colorPrism(elV_vc, prismV_vc, "V"); }
  if(elD_vc){ elD_vc.textContent = prismD_vc.toFixed(2); colorPrism(elD_vc, prismD_vc, "D"); }
}

/* ===== Reverse vector -> final (keeps existing behavior) ===== */
function updateFinalFromVector(){
  const origOD = { S:+document.getElementById('od_origS')?.value || 0, C:+document.getElementById('od_origC')?.value || 0, A:+document.getElementById('od_origA')?.value || 0 };
  const origOS = { S:+document.getElementById('os_origS')?.value || 0, C:+document.getElementById('os_origC')?.value || 0, A:+document.getElementById('os_origA')?.value || 0 };
  const vcOD = { S:+document.getElementById('vc_odS')?.value || 0, C:+document.getElementById('vc_odC')?.value || 0, A:+document.getElementById('vc_odA')?.value || 0 };
  const vcOS = { S:+document.getElementById('vc_osS')?.value || 0, C:+document.getElementById('vc_osC')?.value || 0, A:+document.getElementById('vc_osA')?.value || 0 };

  const finalOD = reverseVectorChange(origOD, vcOD);
  const finalOS = reverseVectorChange(origOS, vcOS);

  const setIf = (id, val)=> { const el = document.getElementById(id); if(el) el.textContent = val; };
  setIf('od_vcFinalS', roundQuarter(finalOD.S));
  setIf('od_vcFinalC', roundQuarter(finalOD.C));
setIf('od_vcFinalA', fmtAxis(finalOD.A));

  setIf('os_vcFinalS', roundQuarter(finalOS.S));
  setIf('os_vcFinalC', roundQuarter(finalOS.C));
setIf('os_vcFinalA', fmtAxis(finalOS.A));

  const bestVCCross = chooseBestDiff(calcBackwardsLens(vcOS, vcOD), calcBackwardsLens(vcOD, vcOS));
  const bestVCCrossPlus = minusToPlus(bestVCCross);
  setIf('vc_crossS', roundQuarter(bestVCCrossPlus.S));
  setIf('vc_crossC', roundQuarter(bestVCCrossPlus.C));
setIf('vc_crossA', fmtAxis(bestVCCrossPlus.A));

  updateCrossedLens();
}



/* ===== Listeners attach after DOM ready ===== */
window.addEventListener("DOMContentLoaded", ()=>{
  // attach vector listeners (if elements exist)
  ['vc_odS','vc_odC','vc_odA','vc_osS','vc_osC','vc_osA','vc_ouS', 'vc_ouC','vc_ouA'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.addEventListener('input', updateFinalFromVector);
  });



  // input list for general updates
  document.querySelectorAll("input").forEach(i=>{
    i.addEventListener('input', updateCrossedLens);
    // keep sphere/cyl input coloring (existing behavior)
    const id = i.id;
    const colorInputs = [
  'od_origS', 'od_origC', 'os_origS', 'os_origC',
  'od_finalS', 'od_finalC', 'os_finalS', 'os_finalC',
  'vc_odS', 'vc_odC', 'vc_osS', 'vc_osC', 'vc_ouS', 'vc_ouC',
  'vd_odS', 'vd_odC', 'vd_osS', 'vd_osC', 'vd_ouS', 'vd_ouC',
  'vd_out_odS', 'vd_out_odC', 'vd_out_osS', 'vd_out_osC', 'vd_out_ouS', 'vd_out_ouC']

;

    if(colorInputs.includes(id)){
      const colorUpdate = ()=> {
        const val = parseFloat(i.value);
        if (!isNaN(val)) i.style.color = (val > 0 ? "green" : (val < 0 ? "red" : "black"));
        else i.style.color = "black";
      };
      i.addEventListener('input', colorUpdate);
      i.addEventListener('blur', ()=>{ const val = parseFloat(i.value); if(!isNaN(val)) i.value = (Math.round(val / 0.25) * 0.25).toFixed(2); colorUpdate(); });
      colorUpdate();
    }
  });

  // initial run
  updateCrossedLens();



});
function fireInputEvents(ids) {
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.dispatchEvent(new Event('input', { bubbles: true }));
    el.dispatchEvent(new Event('change', { bubbles: true }));
  });
}



function copyVD_OU() {
  const s = Number(document.getElementById("vd_out_ouS").textContent);
  const c = Number(document.getElementById("vd_out_ouC").textContent);
  const a = Number(document.getElementById("vd_out_ouA").textContent);

  document.getElementById("vc_ouS").value = s;
  document.getElementById("vc_ouC").value = c;
  document.getElementById("vc_ouA").value = a;

  fireInputEvents(["vc_ouS", "vc_ouC", "vc_ouA"]);

  if (typeof updateFinalFromVector === "function") updateFinalFromVector();
}

function copyVD_OD() {
  const s = Number(document.getElementById("vd_out_odS").textContent);
  const c = Number(document.getElementById("vd_out_odC").textContent);
  const a = Number(document.getElementById("vd_out_odA").textContent);

  document.getElementById("vc_odS").value = s;
  document.getElementById("vc_odC").value = c;
  document.getElementById("vc_odA").value = a;

  fireInputEvents(["vc_odS", "vc_odC", "vc_odA"]);

  if (typeof updateFinalFromVector === "function") updateFinalFromVector();
}

function copyVD_OS() {
  const s = Number(document.getElementById("vd_out_osS").textContent);
  const c = Number(document.getElementById("vd_out_osC").textContent);
  const a = Number(document.getElementById("vd_out_osA").textContent);

  document.getElementById("vc_osS").value = s;
  document.getElementById("vc_osC").value = c;
  document.getElementById("vc_osA").value = a;

  fireInputEvents(["vc_osS", "vc_osC", "vc_osA"]);

  if (typeof updateFinalFromVector === "function") updateFinalFromVector();
}


</script>


<script>
// Format sphere/cylinder: add + for positive, 2 decimals
function fmtPlus(v){
  const n = Number(v);
  if(isNaN(n)) return "-";
  return (n > 0 ? "+" : "") + n.toFixed(2);
}

// Format axis: just round and wrap 0-179, no + sign
function fmtAxis(a){
  const n = Number(a);
  if(isNaN(n)) return "-";
  return Math.round(n) % 180;
}

function updateVDVCSummary() {
  const vdOD = "DC " + fmtPlus(document.getElementById("vd_odS").value) + 
               " ; FC " + fmtPlus(document.getElementById("vd_odC").value) + 
               " × " + fmtAxis(document.getElementById("vd_odA").value);

  const vdOS = "DC " + fmtPlus(document.getElementById("vd_osS").value) + 
               " ; FC " + fmtPlus(document.getElementById("vd_osC").value) + 
               " × " + fmtAxis(document.getElementById("vd_osA").value);

  const vcOD = fmtPlus(document.getElementById("vc_odS").value) + 
               " / " + fmtPlus(document.getElementById("vc_odC").value) + 
               " × " + fmtAxis(document.getElementById("vc_odA").value);

  const vcOS = fmtPlus(document.getElementById("vc_osS").value) + 
               " / " + fmtPlus(document.getElementById("vc_osC").value) + 
               " × " + fmtAxis(document.getElementById("vc_osA").value);

  document.getElementById("vd_odSummary").textContent = vdOD;
  document.getElementById("vd_osSummary").textContent = vdOS;
  document.getElementById("vc_odSummary").textContent = vcOD;
  document.getElementById("vc_osSummary").textContent = vcOS;
}


// Attach to inputs
["vd_odS","vd_odC","vd_odA",
 "vd_osS","vd_osC","vd_osA",
 "vc_odS","vc_odC","vc_odA",
 "vc_osS","vc_osC","vc_osA",]

.forEach(id => {
  const el = document.getElementById(id);
  if(el) el.addEventListener("input", updateVDVCSummary);
});

// Initial update
updateVDVCSummary();


function updateVDVCOUSummary() {
  const vdOU = "DC " + fmtPlus(document.getElementById("vd_ouS").textContent) +
               " ; FC " + fmtPlus(document.getElementById("vd_ouC").textContent) +
               " × " + fmtAxis(document.getElementById("vd_ouA").textContent);

  const vcOU = fmtPlus(document.getElementById("vc_ouS").value) +
               " / " + fmtPlus(document.getElementById("vc_ouC").value) +
               " × " + fmtAxis(document.getElementById("vc_ouA").value);

  const vdEl = document.getElementById("vd_ouSummary");
  if(vdEl) vdEl.textContent = vdOU;

  const vcEl = document.getElementById("vc_ouSummary");
  if(vcEl) vcEl.textContent = vcOU;
}


// Attach to OU inputs
["vd_ouS","vd_ouC","vd_ouA",
 "vc_ouS","vc_ouC","vc_ouA"].forEach(id => {
   const el = document.getElementById(id);
   if(el) el.addEventListener("input", updateVDVCOUSummary);
});

// Initial update
updateVDVCOUSummary();



</script>















<script>
(function(){
  // small helpers (safe, unique names)
  function _parseSpanNumber(txt){
    if(!txt && txt !== 0) return NaN;
    // remove any non-number except - and .
    const cleaned = String(txt).replace(/\+/g,'').replace(/[^\d\.\-]/g,'').trim();
    return cleaned === '' ? NaN : parseFloat(cleaned);
  }

  function _fmtPlus(n){
    if (isNaN(n)) return "-";
    return (n > 0 ? "+" : "") + Number(n).toFixed(2);
  }

  // === Copy functions (global for onclick) ===




window.copyVD_OU = function(){
    const sText = document.getElementById("vd_out_ouS")?.textContent || "";
    const cText = document.getElementById("vd_out_ouC")?.textContent || "";
    const aText = document.getElementById("vd_out_ouA")?.textContent || "";

    const s = _parseSpanNumber(sText);
    const c = _parseSpanNumber(cText);
    const a = _parseSpanNumber(aText);

    if(!isNaN(s) && document.getElementById("vc_ouS")) document.getElementById("vc_ouS").value = s.toFixed(2);
    if(!isNaN(c) && document.getElementById("vc_ouC")) document.getElementById("vc_ouC").value = c.toFixed(2);
    if(!isNaN(a) && document.getElementById("vc_ouA")) document.getElementById("vc_ouA").value = (isNaN(a)?'':a);

    if(typeof updateFinalFromVector === "function") updateFinalFromVector();
};


  window.copyVD_OD = function(){
    const sText = document.getElementById("vd_out_odS")?.textContent || "";
    const cText = document.getElementById("vd_out_odC")?.textContent || "";
    const aText = document.getElementById("vd_out_odA")?.textContent || "";

    const s = _parseSpanNumber(sText);
    const c = _parseSpanNumber(cText);
    const a = _parseSpanNumber(aText);

    if(!isNaN(s) && document.getElementById("vc_odS")) document.getElementById("vc_odS").value = s.toFixed(2);
    if(!isNaN(c) && document.getElementById("vc_odC")) document.getElementById("vc_odC").value = c.toFixed(2);
    if(!isNaN(a) && document.getElementById("vc_odA")) document.getElementById("vc_odA").value = (isNaN(a)?'':a);

    if(typeof updateFinalFromVector === "function") updateFinalFromVector();
  };

  window.copyVD_OS = function(){
    const sText = document.getElementById("vd_out_osS")?.textContent || "";
    const cText = document.getElementById("vd_out_osC")?.textContent || "";
    const aText = document.getElementById("vd_out_osA")?.textContent || "";

    const s = _parseSpanNumber(sText);
    const c = _parseSpanNumber(cText);
    const a = _parseSpanNumber(aText);

    if(!isNaN(s) && document.getElementById("vc_osS")) document.getElementById("vc_osS").value = s.toFixed(2);
    if(!isNaN(c) && document.getElementById("vc_osC")) document.getElementById("vc_osC").value = c.toFixed(2);
    if(!isNaN(a) && document.getElementById("vc_osA")) document.getElementById("vc_osA").value = (isNaN(a)?'':a);

    if(typeof updateFinalFromVector === "function") updateFinalFromVector();
  };



// ===== Helper functions =====
function _parseSpanNumber(text){
  const n = parseFloat(text.replace(/[^\d.-]/g,""));
  return isNaN(n) ? NaN : n;
}
function fmtPlus(n){ return isNaN(n) ? "-" : (n>0?"+":"")+n.toFixed(2); }
function fmtAxis(a){ return isNaN(a) ? "-" : Math.round(a)%180; }

// ===== Copy VD to VC and update summary =====
function copyVD(eye){
  const sText = document.getElementById(`vd_out_${eye}S`)?.textContent || "";
  const cText = document.getElementById(`vd_out_${eye}C`)?.textContent || "";
  const aText = document.getElementById(`vd_out_${eye}A`)?.textContent || "";

  const s = _parseSpanNumber(sText);
  const c = _parseSpanNumber(cText);
  const a = _parseSpanNumber(aText);

  const vcS = document.getElementById(`vc_${eye}S`);
  const vcC = document.getElementById(`vc_${eye}C`);
  const vcA = document.getElementById(`vc_${eye}A`);

  if(!isNaN(s) && vcS) vcS.value = s.toFixed(2);
  if(!isNaN(c) && vcC) vcC.value = c.toFixed(2);
  if(!isNaN(a) && vcA) vcA.value = a;

  // Dispatch input/change so downstream formulas run
  [vcS, vcC, vcA].forEach(el=>{
    if(el){
      el.dispatchEvent(new Event("input",{bubbles:true}));
      el.dispatchEvent(new Event("change",{bubbles:true}));
    }
  });

  // Update final vector calculation
  if(typeof updateFinalFromVector === "function") updateFinalFromVector();

  updateCombinedRound(); // existing combined display updater
}





function copyVD_OU_to_ODOS() {
  const get = id => document.getElementById(id);
  
  // Read input values (not spans)
  const s = parseFloat(get("vd_ouS")?.value) || 0;
  const c = parseFloat(get("vd_ouC")?.value) || 0;
  const a = parseFloat(get("vd_ouA")?.value) || 0;

  // Copy to OD
  ["od","os"].forEach(eye => {
    const vcS = get(`vc_${eye}S`);
    const vcC = get(`vc_${eye}C`);
    const vcA = get(`vc_${eye}A`);
    if(vcS) vcS.value = s.toFixed(2);
    if(vcC) vcC.value = c.toFixed(2);
    if(vcA) vcA.value = a;
    
    // Fire events so listeners update
    [vcS, vcC, vcA].forEach(el => {
      if(el){
        el.dispatchEvent(new Event("input",{bubbles:true}));
        el.dispatchEvent(new Event("change",{bubbles:true}));
      }
    });
  });

  // Update final vector display if function exists
  if(typeof updateFinalFromVector === "function") updateFinalFromVector();

  // Update OU summary display
  const vdOU = "DC " + fmtPlus(s) + " ; FC " + fmtPlus(c) + " × " + fmtAxis(a);
  const vcOU = fmtPlus(s) + " / " + fmtPlus(c) + " × " + fmtAxis(a);
  if(get("vd_ouSummary")) get("vd_ouSummary").textContent = vdOU;
  if(get("vc_ouSummary")) get("vc_ouSummary").textContent = vcOU;
}



window.copyVD_OU = ()=>copyVD("ou");
window.copyVD_OD = ()=>copyVD("od");
window.copyVD_OS = ()=>copyVD("os");




// ===== Combined display updater =====
function updateCombinedRound(){
  ["od","os"].forEach(eye=>{
    const S = document.getElementById(`${eye}_roundS`)?.textContent || "-";
    const C = document.getElementById(`${eye}_roundC`)?.textContent || "-";
    const A = document.getElementById(`${eye}_roundA`)?.textContent || "-";
    const el = document.getElementById(`${eye}_roundCombinedDisplay`);
    if(el) el.textContent = `${S} / ${C} × ${A}`;
  });
}

// ===== Observe changes =====
["od_roundS","od_roundC","od_roundA","os_roundS","os_roundC","os_roundA"].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  new MutationObserver(updateCombinedRound).observe(el, { childList:true, characterData:true, subtree:true });
});

// Initial update
updateCombinedRound();








  // === Combined display updaters ===
  function updateCombinedVC(){
    const odS = document.getElementById("od_vcFinalS")?.textContent || "-";
    const odC = document.getElementById("od_vcFinalC")?.textContent || "-";
    const odA = document.getElementById("od_vcFinalA")?.textContent || "-";
    const osS = document.getElementById("os_vcFinalS")?.textContent || "-";
    const osC = document.getElementById("os_vcFinalC")?.textContent || "-";
    const osA = document.getElementById("os_vcFinalA")?.textContent || "-";

    const odCombEl = document.getElementById("od_vcCombined");
    const osCombEl = document.getElementById("os_vcCombined");
    if(odCombEl) odCombEl.textContent = `${odS} / ${odC} × ${odA}`;
    if(osCombEl) osCombEl.textContent = `${osS} / ${osC} × ${osA}`;
  }

function fmtPlus(v){
  const n = Number(v);
  if(isNaN(n)) return "-";
  return (n > 0 ? "+" : "") + n.toFixed(2);
}

function fmtAxis(a){
  const n = Number(a);
  if(isNaN(n)) return "-";
  return Math.round(n) % 180;
}

function updateCombinedOriginal(){
  const odS = document.getElementById("od_origS")?.value;
  const odC = document.getElementById("od_origC")?.value;
  const odA = document.getElementById("od_origA")?.value;

  const osS = document.getElementById("os_origS")?.value;
  const osC = document.getElementById("os_origC")?.value;
  const osA = document.getElementById("os_origA")?.value;

  const odEl = document.getElementById("od_origCombined");
  const osEl = document.getElementById("os_origCombined");

  if(odEl) odEl.textContent = `${fmtPlus(odS)} / ${fmtPlus(odC)} × ${fmtAxis(odA)}`;
  if(osEl) osEl.textContent = `${fmtPlus(osS)} / ${fmtPlus(osC)} × ${fmtAxis(osA)}`;
}

// auto-update when inputs change
["od_origS","od_origC","od_origA","os_origS","os_origC","os_origA"].forEach(id=>{
  const el = document.getElementById(id);
  if(el) el.addEventListener("input", updateCombinedOriginal);
});

// initial run
updateCombinedOriginal();

  function updateCombinedFinal(){
    const odS = document.getElementById("od_finalS")?.value;
    const odC = document.getElementById("od_finalC")?.value;
    const odA = document.getElementById("od_finalA")?.value;
    const osS = document.getElementById("os_finalS")?.value;
    const osC = document.getElementById("os_finalC")?.value;
    const osA = document.getElementById("os_finalA")?.value;

    const odCombEl = document.getElementById("od_finalCombined");
    const osCombEl = document.getElementById("os_finalCombined");

    if(odCombEl) odCombEl.textContent = `${_fmtPlus(Number(odS))} / ${_fmtPlus(Number(odC))} × ${odA || "-"}`;
    if(osCombEl) osCombEl.textContent = `${_fmtPlus(Number(osS))} / ${_fmtPlus(Number(osC))} × ${osA || "-"}`;
  }

  // === Observe updates to vcFinal spans (they are updated by your code) ===
  function _observeIfExists(selectorList, cb){
    selectorList.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      const mo = new MutationObserver(cb);
      mo.observe(el, { childList: true, characterData: true, subtree: true });
    });
  }

  // Attach when DOM ready
  window.addEventListener("DOMContentLoaded", ()=>{
    // observe vcFinal spans so combined VC updates when updateFinalFromVector writes to them
    _observeIfExists(["od_vcFinalS","od_vcFinalC","od_vcFinalA","os_vcFinalS","os_vcFinalC","os_vcFinalA"], updateCombinedVC);
    // initial run
    updateCombinedVC();

    // attach listeners to manual final inputs so combined final updates immediately
    ["od_finalS","od_finalC","od_finalA","os_finalS","os_finalC","os_finalA"].forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.addEventListener("input", updateCombinedFinal);
    });
    updateCombinedFinal();

    // also observe vd_out spans if they exist — keep them normalized (no destructive edits)
    // (This does not change original behaviour; only ensures numbers are parseable when copying)
    _observeIfExists(["vd_out_odS","vd_out_odC","vd_out_odA",
 "vd_out_osS","vd_out_osC","vd_out_osA",
 "vd_out_ouS","vd_out_ouC","vd_out_ouA"]
, 

function(){
      // noop: observation kept in place to ensure future expansions possible; we call nothing here
    });
  });

  // Expose safe helpers for debugging if needed
  window._vdHelpers = { parseSpanNumber: _parseSpanNumber, fmtPlus: _fmtPlus, updateCombinedVC, updateCombinedFinal };

})();
</script>


<!-- your existing HTML content -->

<script>
// === Original Prism Calculation ===
function updateOriginalPrism() {
  const od = {
    S: Number(document.getElementById('od_origS').value) || 0,
    C: Number(document.getElementById('od_origC').value) || 0,
    A: Number(document.getElementById('od_origA').value) || 0
  };
  const os = {
    S: Number(document.getElementById('os_origS').value) || 0,
    C: Number(document.getElementById('os_origC').value) || 0,
    A: Number(document.getElementById('os_origA').value) || 0
  };

  const M_od = od.S + od.C/2;
  const A_od = od.A * Math.PI/180;
  const J0_od = -od.C/2 * Math.cos(2*A_od);
  const J45_od = -od.C/2 * Math.sin(2*A_od);

  const M_os = os.S + os.C/2;
  const A_os = os.A * Math.PI/180;
  const J0_os = -os.C/2 * Math.cos(2*A_os);
  const J45_os = -os.C/2 * Math.sin(2*A_os);

  const dec = 12/10; // example factor

  const prismH = Math.abs((M_od - M_os + J0_od - J0_os) );
  const prismV = Math.abs((M_od - M_os - (J0_od - J0_os)) );
  const prismD = Math.max(Math.abs(M_od - M_os + J45_od - J45_os), Math.abs(M_od - M_os - (J45_od - J45_os))) ;

  document.getElementById('origCrossS').textContent = prismH.toFixed(2);
  document.getElementById('origCrossC').textContent = prismV.toFixed(2);
  document.getElementById('origCrossA').textContent = prismD.toFixed(2);
}

// attach listeners
['od_origS','od_origC','od_origA','os_origS','os_origC','os_origA'].forEach(id=>{
  const el = document.getElementById(id);
  if(el) el.addEventListener('input', updateOriginalPrism);
});

// initial run
updateOriginalPrism();
</script>

<script>
// turn opacity ON immediately at page load
document.addEventListener("DOMContentLoaded", function() {
  document.querySelectorAll(".mask1").forEach(row => row.classList.add("hidden-row"));
  document.querySelectorAll(".mask2").forEach(row => row.classList.add("hidden-row"));
  document.querySelectorAll(".mask3").forEach(row => row.classList.add("hidden-row"));

});



document.getElementById("toggleMask2").addEventListener("click", function() {
  document.querySelectorAll(".mask2").forEach(row => {
    row.classList.toggle("hidden-row");
  });
});


document.getElementById("toggleMask3").addEventListener("click", function() {
  document.querySelectorAll(".mask3").forEach(row => {
    row.classList.toggle("hidden-row");
  });
});

</script>
<script>
function toggleManualMask1() {
  document.querySelectorAll(".mask1").forEach(row => row.classList.toggle("hidden-row"));
}

// Attach the same function to both buttons
document.getElementById("toggleMask1").addEventListener("click", toggleManualMask1);
document.getElementById("toggleMask1_copy").addEventListener("click", toggleManualMask1);
</script>

<script>
function sendWhatsapp() {
  const number = document.getElementById("customerWhatsapp").value.trim().replace(/\D/g,'');
  const name = document.getElementById("customerName").value.trim();
  const notes = document.getElementById("notes").value.trim();

  if(!number) return;

  const msg = `Greetings ${name} from Kiara Optometry! ${notes}`;
  window.open(`https://wa.me/${number}?text=${encodeURIComponent(msg)}`, "_blank");
}

document.getElementById("sendWhatsappBtn").addEventListener("click", sendWhatsapp);
</script>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
function capturePart() {
  const target = document.getElementById("captureTarget");

  html2canvas(target).then(fullCanvas => {

    // crop 70px from the top
    const cropY = 70;
    const w = fullCanvas.width;
    const h = fullCanvas.height - cropY;

    const cropped = document.createElement("canvas");
    cropped.width = w;
    cropped.height = h;

    const ctx = cropped.getContext("2d");
    ctx.drawImage(fullCanvas, 0, cropY, w, h, 0, 0, w, h);

// save JPG with customer name and current date
const link = document.createElement("a");
const name = document.getElementById("customerName")?.value || "Unnamed";
const now = new Date();
const day = String(now.getDate()).padStart(2, '0');
const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
const month = monthNames[now.getMonth()]; // 0-indexed
const year = now.getFullYear();

const today = `${day}-${month}-${year}`; // e.g., 12-Dec-2025
link.download = `${name}_${today}.jpg`;
link.href = cropped.toDataURL("image/jpeg", 0.9);
link.click();

  });
}
</script>

<script>
// --- Reliable OU summary updater + small hookup to copy function ---
// (safe: doesn't remove your older scripts, only augments them)

(function(){
  const get = id => document.getElementById(id);

  function updateVDVCOUSummary() {
    // Read values from the VD (inputs) and VC (inputs)
    const vdS = get("vd_ouS")?.value ?? "";
    const vdC = get("vd_ouC")?.value ?? "";
    const vdA = get("vd_ouA")?.value ?? "";

    const vcS = get("vc_ouS")?.value ?? "";
    const vcC = get("vc_ouC")?.value ?? "";
    const vcA = get("vc_ouA")?.value ?? "";

    // Build formatted strings using your existing helpers (fmtPlus/fmtAxis)
    const vdOU = "DC " + fmtPlus(vdS) + " ; FC " + fmtPlus(vdC) + " × " + fmtAxis(vdA);
    const vcOU = fmtPlus(vcS) + " / " + fmtPlus(vcC) + " × " + fmtAxis(vcA);

    const vdEl = get("vd_ouSummary");
    const vcEl = get("vc_ouSummary");
    if (vdEl) vdEl.textContent = vdOU;
    if (vcEl) vcEl.textContent = vcOU;
  }

  // attach listeners for live updates
  ["vd_ouS","vd_ouC","vd_ouA","vc_ouS","vc_ouC","vc_ouA"].forEach(id=>{
    const el = get(id);
    if (el) el.addEventListener("input", updateVDVCOUSummary);
  });

  // Ensure the OU summary updates immediately after your copy function runs.
  // If you already have a window.copyVD_OU function, wrap it so it still runs then updates summary.
  const origCopy = window.copyVD_OU;
  window.copyVD_OU = function(...args) {
    try {
      if (typeof origCopy === "function") origCopy.apply(this, args);
    } catch(e) {
      // swallow to avoid breaking page; still continue to update summary
      console.error("copyVD_OU wrapped error:", e);
    }
    // Trigger the summary update and also trigger input events on vc_ou inputs
    // so any downstream listeners (coloring/rounding/formulas) run.
    updateVDVCOUSummary();
    ["vc_ouS","vc_ouC","vc_ouA"].forEach(id=>{
      const el = get(id);
      if (el) {
        el.dispatchEvent(new Event("input", { bubbles: true }));
        el.dispatchEvent(new Event("change", { bubbles: true }));
      }
    });
  };

  // call once on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", updateVDVCOUSummary);
  } else {
    updateVDVCOUSummary();
  }

  // expose for quick debugging if helpful
  window._updateVDVCOUSummary = updateVDVCOUSummary;
})();
</script>


<script>
(function(){
  const byId = id => document.getElementById(id);

  // Safe attach helper
  function safeOn(id, evt, cb){
    const el = byId(id);
    if(el) el.addEventListener(evt, cb);
  }

  // safe fmt helpers (reuse if you already have them)
  function fmtPlusLocal(v){
    const n = Number(v);
    if (isNaN(n)) return "-";
    return (n > 0 ? "+" : "") + n.toFixed(2);
  }
  function fmtAxisLocal(a){
    const n = Number(a);
    if (isNaN(n)) return "-";
    return Math.round(n) % 180;
  }

  // Robust copy function exposed on window
  window.copyVD_OU_to_ODOS = function(){
    const get = byId;
    // Read VD (inputs) — keep empty as blank (don't coerce to zero)
    const sRaw = get("vd_ouS")?.value ?? "";
    const cRaw = get("vd_ouC")?.value ?? "";
    const aRaw = get("vd_ouA")?.value ?? "";

    const s = sRaw.trim() === "" ? NaN : parseFloat(sRaw);
    const c = cRaw.trim() === "" ? NaN : parseFloat(cRaw);
    const a = aRaw.trim() === "" ? NaN : parseFloat(aRaw);

    // target eyes
    ["od","os"].forEach(eye => {
      const vcS = get(`vc_${eye}S`);
      const vcC = get(`vc_${eye}C`);
      const vcA = get(`vc_${eye}A`);

      if(vcS) vcS.value = isNaN(s) ? (vcS.value || "") : s.toFixed(2);
      if(vcC) vcC.value = isNaN(c) ? (vcC.value || "") : c.toFixed(2);
      if(vcA) vcA.value = isNaN(a) ? (vcA.value || "") : (Math.round(a)==a ? a : a); // keep axis raw

      // dispatch events safely
      [vcS, vcC, vcA].forEach(el => {
        if(el){
          el.dispatchEvent(new Event("input", { bubbles: true }));
          el.dispatchEvent(new Event("change", { bubbles: true }));
        }
      });
    });

    // try update hook if present (safe)
    try {
      if(typeof window.updateFinalFromVector === "function") window.updateFinalFromVector();
    } catch(e){
      console.warn("updateFinalFromVector threw", e);
    }

    // update OU summaries if elements exist
    const vdOU = "DC " + fmtPlusLocal(sRaw) + " ; FC " + fmtPlusLocal(cRaw) + " × " + fmtAxisLocal(aRaw);
    const vcOU = fmtPlusLocal(sRaw) + " / " + fmtPlusLocal(cRaw) + " × " + fmtAxisLocal(aRaw);
    if(get("vd_ouSummary")) get("vd_ouSummary").textContent = vdOU;
    if(get("vc_ouSummary")) get("vc_ouSummary").textContent = vcOU;
  };

  // Attach safe listeners for your toggle buttons (avoid null .addEventListener errors)
  safeOn("toggleMask1", "click", () => document.querySelectorAll(".mask1").forEach(r => r.classList.toggle("hidden-row")));
  safeOn("toggleMask1_copy", "click", () => document.querySelectorAll(".mask1").forEach(r => r.classList.toggle("hidden-row")));
  safeOn("toggleMask2", "click", () => document.querySelectorAll(".mask2").forEach(r => r.classList.toggle("hidden-row")));
  safeOn("toggleMask3", "click", () => document.querySelectorAll(".mask3").forEach(r => r.classList.toggle("hidden-row")));

  // Attach the copy function to a button with id exactly "copyVD_OU_to_ODOS" if present
  safeOn("copyVD_OU_to_ODOS", "click", () => window.copyVD_OU_to_ODOS());

  // If you prefer a programmatic trigger elsewhere, call window.copyVD_OU_to_ODOS()

})();
</script>











</body>
</html>
