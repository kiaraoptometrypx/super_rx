<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ultimate Calculator</title>
<style>

th.red, td.red {
  background: #F5EFED;
  color: black;
}
th.yellow, td.yellow {
  background: #FFFEF2;
  color: black;
}
th.blue, td.blue {
  background: #F2FFFA;
  color: black;
}

.hidden-row {
  opacity: 0.1;       /* semi-transparent */
  pointer-events: none; /* optional: disable interactions */
}

  body {
    font-family: 'Manrope', sans-serif;
    padding: 20px;
    background: #f5f5f5;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  table {
    border-collapse: collapse;
    width: 100%;
    max-width: 700px;
    margin-top: 20px;
    text-align: center;
  }

  th, td {
    border: 1px solid #aaa;
    padding: 10px 14px;
    text-align: center;
  }

  th {
    background: #eee;
    font-weight: 600;
  }

  input {
    width: 70px;
    text-align: center;
    padding: 4px 6px;
    border: 1px solid lightgrey;
    border-radius:6px;
  }
</style>

</head>
<body>

<h2>Superposition Refraction</h2>

<table>
  
<tr><th class="red" colspan="4">Current RX</th></tr>

<!-- OD -->

<tr>
  <td>Right</td>
  <td>Sph : <input type="number" step="0.25" id="od_origS"></td>
  <td>Cyl : <input type="number" step="0.25" id="od_origC"></td>
  <td>Axis : <input type="number" step="5" min="0" max="180" id="od_origA"></td>
</tr>
<tr>
  <td>Left</td>
  <td>Sph : <input type="number" step="0.25" id="os_origS"></td>
  <td>Cyl : <input type="number" step="0.25" id="os_origC"></td>
  <td>Axis : <input type="number" step="5" min="0" max="180" id="os_origA"></td>
</tr>


<tr><th class="red" colspan="4"></th></tr>
<tr><td colspan="5" style="border:none"></td></tr>

<!-- Manual Subjective Refraction -->
<tr>
<th class="blue" colspan="4">Subjective Refraction</th>

<tr class="mask1">
  <td>R Dx</td>
  <td id="od_roundS"></td>
  <td id="od_roundC"></td>
  <td id="od_roundA"></td>
</tr>

<tr class="mask1">
  <td>L Dx</td>
  <td id="os_roundS"></td>
  <td id="os_roundC"></td>
  <td id="os_roundA"></td>
</tr>
<tr class="mask1">
  <td>Bino Dx</td>
  <td id="diffCrossS"></td>
  <td id="diffCrossC"></td>
  <td id="diffCrossA"></td>
</tr>




<tr style="display:none">
  <td colspan="2">Crossed OD</td>
  <td id="od_crossS"></td>
  <td id="od_crossC"></td>
  <td id="od_crossA"></td>
</tr>
<tr style="display:none">
  <td colspan="2">Crossed OS</td>
  <td id="os_crossS"></td>
  <td id="os_crossC"></td>
  <td id="os_crossA"></td>
</tr>
<th colspan="4"></th>
<tr class="mask1">
  <td>Right</td>
  <td>Sph : <input type="number" step="0.25" id="od_finalS"></td>
  <td>Cyl : <input type="number" step="0.25" id="od_finalC"></td>
  <td>Axis : <input type="number" step="5" min="0" max="180" id="od_finalA"></td>
</tr>
<tr class="mask1">
  <td>Left</td>
  <td>Sph : <input type="number" step="0.25" id="os_finalS"></td>
  <td>Cyl : <input type="number" step="0.25" id="os_finalC"></td>
  <td>Axis : <input type="number" step="5" min="0" max="180" id="os_finalA"></td>
</tr>


<th class="blue" colspan="4"></th>
<tr><td colspan="4" style="border:none"></td></tr>






<!-- Vector Refraction -->
<tr>
  <th class="yellow" colspan="4">Vector Refraction</th></tr>
<tr>
  <td>FC DC Bal R<br><button onclick="copyVD_OD()" style="width:80px; height:30px">Export</button></td>
  <td>
    Sph : <input type="number" step="0.25" id="vd_odS"><br>
    <span id="vd_out_odS">-</span>
  </td>
  <td>
    Cyl : <input type="number" step="0.25" id="vd_odC"><br>
    <span id="vd_out_odC">-</span>
  </td>
  <td>
    Axis : <input type="number" step="5" min="0" max="180" id="vd_odA"><br>
    <span id="vd_out_odA">-</span>
  </td>
</tr>

<tr>
  <td>FC DC Bal L<br><button onclick="copyVD_OS()" style="width:80px; height:30px">Export</button>
</td>
  <td>
    Sph : <input type="number" step="0.25" id="vd_osS"><br>
    <span id="vd_out_osS">-</span>
  </td>
  <td>
    Cyl : <input type="number" step="0.25" id="vd_osC"><br>
    <span id="vd_out_osC">-</span>
  </td>
  <td>
    Axis : <input type="number" step="5" min="0" max="180" id="vd_osA"><br>
    <span id="vd_out_osA">-</span>
  </td>
</tr>
<tr>
  <td>R Dx</td>
  <td><input type="number" step="0.25" id="vc_odS"></td>
  <td><input type="number" step="0.25" id="vc_odC"></td>
  <td><input type="number" step="5" min="0" max="180" id="vc_odA"></td>
</tr>
<tr>
  <td>L Dx</td>
  <td><input type="number" step="0.25" id="vc_osS"></td>
  <td><input type="number" step="0.25" id="vc_osC"></td>
  <td><input type="number" step="5" min="0" max="180" id="vc_osA"></td>
</tr>
<tr>
  <td>Bino Dx</td>
  <td id="vc_crossS">-</td>
  <td id="vc_crossC">-</td>
  <td id="vc_crossA">-</td>
</tr>
<tr><th colspan="4"></th>
<tr>
  <td>Right</td>
  <td>Sph : <span id="od_vcFinalS">0.00</span></td>
  <td>Cyl : <span id="od_vcFinalC">0.00</span></td>
  <td>Axis : <span id="od_vcFinalA">-</span></td>
</tr>

<tr>
  <td>Left</td>
  <td>Sph : <span id="os_vcFinalS">0.00</span></td>
  <td>Cyl : <span id="os_vcFinalC">0.00</span></td>
  <td>Axis : <span id="os_vcFinalA">-</span></td>
</tr>



<tr><th class="yellow" colspan="4"></th>








<tr><td colspan="4" style="border:none"></td></tr>
<tr><th colspan="4">Summary</th></tr>
<tr>
  <td colspan="4">
    Gaze Angle from Center: 
    <input type="range" id="gazeAngle" step="5" value="35" min="10" max="50" oninput="this.nextElementSibling.value = this.value">
    <output>35</output>

    <span style="display:inline-block; width:40px;"></span> <!-- gap -->

    Vertex Distance (mm): 
    <input type="range" id="vertexDist" step="1" value="14" min="10" max="20" oninput="this.nextElementSibling.value = this.value">
    <output>14</output>
  </td>
</tr>

</td>
  </tr>
<tr>
  <td class="red">Current Rx</td>
  <td colspan="3" class="red">
    R: <span id="od_origCombined" style="margin-right: 100px;">OD -</span>
    L: <span id="os_origCombined">OS -</span>
  </td>
</tr>
<tr>
  <td class="red">Current Prism</td>
  <td class="red" colspan="3">
    H : <span id="origCrossS" style="margin-right: 50px;">-</span>
    V : <span id="origCrossC" style="margin-right: 50px;">-</span>
    D : <span id="origCrossA">-</span>
  </td>
</tr>

<tr class="mask1">
  <td class="blue">Subjective Rx</td>
  <td class="blue" colspan="3">
    R : <span id="od_finalCombined" style="margin-right: 100px;">OD -</span>
    L : <span id="os_finalCombined">OS -</span>
  </td>
</tr>

<tr class="mask1">
  <td class="blue">Prism Changes</td>
  <td class="blue" colspan="3">
    H : <span id="prismH" style="margin-right: 50px;">-</span>
    V : <span id="prismV" style="margin-right: 50px;">-</span>
    D : <span id="prismD">-</span>
  </td>
</tr>

<tr>
  <td class="yellow">Vector Rx</td>
  <td class="yellow" colspan="3">
    R : <span id="od_vcCombined" style="margin-right: 100px;">OD -</span>
    L : <span id="os_vcCombined">OS -</span>
  </td>
</tr>

<tr>
  <td class="yellow">Prism Changes</td>
  <td class="yellow" colspan="3">
    H : <span id="prismH_vc" style="margin-right: 50px;">-</span>
    V : <span id="prismV_vc" style="margin-right: 50px;">-</span>
    D : <span id="prismD_vc">-</span>
  </td>
</tr>




<tr><th colspan="4"></th></tr>



</table>
<div style="height:20px"></div>


<button style="background-color:#F2FFFA; border-radius:10px; height:50px; width:125px" id="toggleMask1">Hide/Show<br>Subjective RX</button>


<div style="height:350px"></div>






<script>




function fmtAxis(a){
  if(a === 0 || a === "0") return 180;
  return a;
}


function calcVD(side) {
  const S = Number(document.getElementById(`vd_${side}S`).value) || 0;
  const C = Number(document.getElementById(`vd_${side}C`).value) || 0;
  const A = Number(document.getElementById(`vd_${side}A`).value) || 0;

  const sphAdj = -(C / 2);
  const outS = S + sphAdj;
  const outC = C;
  const outA = A;

  const fmt = v => (v > 0 ? "+" : "") + v.toFixed(2);

  document.getElementById(`vd_out_${side}S`).textContent = fmt(outS);
  document.getElementById(`vd_out_${side}C`).textContent = fmt(outC);
  document.getElementById(`vd_out_${side}A`).textContent = outA;
}


["od","os"].forEach(side => {
  ["S","C","A"].forEach(f => {
    document.getElementById(`vd_${side}${f}`).addEventListener("input", () => calcVD(side));
  });
});
</script>



<script>
/* ===== Utilities ===== */
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

function normalizeMinus(lens){
  let S = Number(lens.S), C = Number(lens.C), A = Number(lens.A);
  if (isNaN(S)) S = 0; if (isNaN(C)) C = 0; if (isNaN(A)) A = 0;
  if (C > 0){ S += C; C = -C; A = (A + 90) % 180; }
  A = ((A % 180) + 180) % 180;
  return { S: +S, C: +C, A: Math.round(A) % 180 };
}
function toFixed2Num(v){ return +Number(v).toFixed(2); }
function minusToPlus(lens){
  const m = normalizeMinus(lens);
  return { S: toFixed2Num(m.S + m.C), C: toFixed2Num(-m.C), A: Math.round((m.A + 90) % 180) };
}
function roundQuarter(v){
  if(isNaN(v)) return "-";
  const r = Math.round(v / 0.25) * 0.25;
  return (r > 0 ? "+" : "") + r.toFixed(2);
}

function fmtPlus(v){
  const n = Number(v);
  if (isNaN(n)) return "-";
  return (n > 0 ? "+" : "") + n.toFixed(2);
}


function calcDecentration(angleDeg, vertexMM){ return (vertexMM / 10) * Math.tan(angleDeg * Math.PI/180); }

/* ===== Vector & lens math (unchanged) ===== */
function calcBackwardsLens(orig, final){
  const rx1 = normalizeMinus(orig), rxF = normalizeMinus(final);
  const M1 = rx1.S + rx1.C/2;
  const J01 = -rx1.C/2 * Math.cos(2 * deg2rad(rx1.A));
  const J451 = -rx1.C/2 * Math.sin(2 * deg2rad(rx1.A));
  const MF = rxF.S + rxF.C/2;
  const J0F = -rxF.C/2 * Math.cos(2 * deg2rad(rxF.A));
  const J45F = -rxF.C/2 * Math.sin(2 * deg2rad(rxF.A));
  const Mx = MF - M1;
  const J0x = J0F - J01;
  const J45x = J45F - J451;
  const Cx = -2 * Math.sqrt(J0x*J0x + J45x*J45x);
  const Sx = Mx - Cx/2;
  let Ax = 0.5 * rad2deg(Math.atan2(J45x, J0x)); if (Ax < 0) Ax += 180;
  return { S: toFixed2Num(Sx), C: toFixed2Num(Cx), A: Math.round(Ax) % 180 };
}
function pickClosestSphere(candidates){
  const normalized = candidates.map(c => normalizeMinus(c));
  let best = normalized[0];
  for(const c of normalized){ if(Math.abs(c.S) < Math.abs(best.S)) best = c; }
  best.S = toFixed2Num(best.S); best.C = toFixed2Num(best.C); best.A = Math.round(best.A) % 180;
  return best;
}
function bestSingleLens(lens){
  const form1 = { S: lens.S, C: lens.C, A: lens.A };
  const form2 = { S: lens.S + lens.C, C: -lens.C, A: (lens.A + 90) % 180 };
  return pickClosestSphere([form1, form2]);
}
function chooseBestDiff(diff1, diff2){
  const forms = l => [{S:l.S,C:l.C,A:l.A},{S:l.S+l.C,C:-l.C,A:(l.A+90)%180}];
  return pickClosestSphere([...forms(diff1), ...forms(diff2)]);
}
function reverseVectorChange(orig, vector){
  const rxOrig = normalizeMinus(orig), rxVec = normalizeMinus(vector);
  const M1 = rxOrig.S + rxOrig.C/2;
  const J01 = -rxOrig.C/2 * Math.cos(2*deg2rad(rxOrig.A));
  const J451 = -rxOrig.C/2 * Math.sin(2*deg2rad(rxOrig.A));
  const Mx = rxVec.S + rxVec.C/2;
  const J0x = -rxVec.C/2 * Math.cos(2*deg2rad(rxVec.A));
  const J45x = -rxVec.C/2 * Math.sin(2*deg2rad(rxVec.A));
  const MF = M1 + Mx;
  const J0F = J01 + J0x;
  const J45F = J451 + J45x;
  const CF = -2 * Math.sqrt(J0F*J0F + J45F*J45F);
  const SF = MF - CF/2;
  let AF = 0.5 * rad2deg(Math.atan2(J45F, J0F)); if (AF < 0) AF += 180;
  return bestSingleLens({ S: toFixed2Num(SF), C: toFixed2Num(CF), A: Math.round(AF) % 180 });
}

/* ===== Prism color helper, type-specific ===== */
function colorPrism(el, value, type){
  if(!el) return;
  const absVal = Math.abs(Number(value) || 0);
  if(type === "H") el.style.color = absVal < 0.5 ? "green" : absVal < 1 ? "orange" : "red";
  else if(type === "V") el.style.color = absVal < 0.125 ? "green" : absVal < 0.25 ? "orange" : "red";
  else if(type === "D") el.style.color = absVal < 0.375 ? "green" : absVal < 0.75 ? "orange" : "red";
}

/* ===== Main update function (integrated, robust) ===== */
function updateCrossedLens(){
  // read inputs (safe fallback 0)
  const odOrig = { S:+document.getElementById('od_origS')?.value || 0, C:+document.getElementById('od_origC')?.value || 0, A:+document.getElementById('od_origA')?.value || 0 };
  const odFinal = { S:+document.getElementById('od_finalS')?.value || 0, C:+document.getElementById('od_finalC')?.value || 0, A:+document.getElementById('od_finalA')?.value || 0 };
  const osOrig = { S:+document.getElementById('os_origS')?.value || 0, C:+document.getElementById('os_origC')?.value || 0, A:+document.getElementById('os_origA')?.value || 0 };
  const osFinal = { S:+document.getElementById('os_finalS')?.value || 0, C:+document.getElementById('os_finalC')?.value || 0, A:+document.getElementById('os_finalA')?.value || 0 };

  // cross calculations (same as before)
  const odCross = bestSingleLens(calcBackwardsLens(odOrig, odFinal));
  const odPlus = minusToPlus(odCross);
  const osCross = bestSingleLens(calcBackwardsLens(osOrig, osFinal));
  const osPlus = minusToPlus(osCross);

  // safe element writes (only if elements exist)
  const setIf = (id, val)=> { const el = document.getElementById(id); if(el) el.textContent = val; };
  setIf('od_crossS', odCross.S);
  setIf('od_crossC', odCross.C);
setIf('od_crossA', fmtAxis(odCross.A));
  setIf('od_roundS', roundQuarter(odPlus.S));
  setIf('od_roundC', roundQuarter(odPlus.C));
setIf('od_roundA', fmtAxis(odPlus.A));

  setIf('os_crossS', osCross.S);
  setIf('os_crossC', osCross.C);
setIf('os_crossA', fmtAxis(osCross.A));
  setIf('os_roundS', roundQuarter(osPlus.S));
  setIf('os_roundC', roundQuarter(osPlus.C));
setIf('os_roundA', fmtAxis(osPlus.A));

  const bestDiff = chooseBestDiff(calcBackwardsLens(osCross, odCross), calcBackwardsLens(odCross, osCross));
  const bestDiffPlus = minusToPlus(bestDiff);

  setIf('diffCrossS', roundQuarter(bestDiffPlus.S));
  setIf('diffCrossC', roundQuarter(bestDiffPlus.C));
setIf('diffCrossA', fmtAxis(bestDiffPlus.A));

  // decentration (used by prism calculation)
  const gaze = +document.getElementById("gazeAngle")?.value || 30;
  const vertex = +document.getElementById("vertexDist")?.value || 12;
  const dec = calcDecentration(gaze, vertex);

  // prism from bestDiff vector
  const A_rad = deg2rad(bestDiff.A);
  const M = bestDiff.S + bestDiff.C/2;
  const J0 = -bestDiff.C/2 * Math.cos(2 * A_rad);
  const J45 = -bestDiff.C/2 * Math.sin(2 * A_rad);

  const prismH = Math.abs((M + J0) * dec);
  const prismV = Math.abs((M - J0) * dec);
  const prism45 = Math.abs((M - J45) * dec);
  const prism135 = Math.abs((M + J45) * dec);
  const prismD = Math.max(prism45, prism135);

  // write and color main prism outputs
  const elH = document.getElementById("prismH");
  const elV = document.getElementById("prismV");
  const elD = document.getElementById("prismD");
  if(elH){ elH.textContent = prismH.toFixed(2); colorPrism(elH, prismH, "H"); }
  if(elV){ elV.textContent = prismV.toFixed(2); colorPrism(elV, prismV, "V"); }
  if(elD){ elD.textContent = prismD.toFixed(2); colorPrism(elD, prismD, "D"); }

  // VC prism section (if vc_cross elements exist we parse them safely)
  const vc_crossS_text = document.getElementById("vc_crossS")?.textContent;
  const vc_crossC_text = document.getElementById("vc_crossC")?.textContent;
  const vc_crossA_text = document.getElementById("vc_crossA")?.textContent;
  // parseFloat returns NaN for "-", fallback to 0
  const vcS = Number.parseFloat(vc_crossS_text) || 0;
  const vcC = Number.parseFloat(vc_crossC_text) || 0;
  const vcA = Number.parseFloat(vc_crossA_text) || 0;
  const A_vc_rad = deg2rad(vcA);
  const M_vc = vcS + vcC/2;
  const J0_vc = -vcC/2 * Math.cos(2 * A_vc_rad);
  const J45_vc = -vcC/2 * Math.sin(2 * A_vc_rad);
  const prismH_vc = Math.abs((M_vc + J0_vc) * dec);
  const prismV_vc = Math.abs((M_vc - J0_vc) * dec);
  const prism45_vc = Math.abs((M_vc - J45_vc) * dec);
  const prism135_vc = Math.abs((M_vc + J45_vc) * dec);
  const prismD_vc = Math.max(prism45_vc, prism135_vc);

  const elH_vc = document.getElementById("prismH_vc");
  const elV_vc = document.getElementById("prismV_vc");
  const elD_vc = document.getElementById("prismD_vc");
  if(elH_vc){ elH_vc.textContent = prismH_vc.toFixed(2); colorPrism(elH_vc, prismH_vc, "H"); }
  if(elV_vc){ elV_vc.textContent = prismV_vc.toFixed(2); colorPrism(elV_vc, prismV_vc, "V"); }
  if(elD_vc){ elD_vc.textContent = prismD_vc.toFixed(2); colorPrism(elD_vc, prismD_vc, "D"); }
}

/* ===== Reverse vector -> final (keeps existing behavior) ===== */
function updateFinalFromVector(){
  const origOD = { S:+document.getElementById('od_origS')?.value || 0, C:+document.getElementById('od_origC')?.value || 0, A:+document.getElementById('od_origA')?.value || 0 };
  const origOS = { S:+document.getElementById('os_origS')?.value || 0, C:+document.getElementById('os_origC')?.value || 0, A:+document.getElementById('os_origA')?.value || 0 };
  const vcOD = { S:+document.getElementById('vc_odS')?.value || 0, C:+document.getElementById('vc_odC')?.value || 0, A:+document.getElementById('vc_odA')?.value || 0 };
  const vcOS = { S:+document.getElementById('vc_osS')?.value || 0, C:+document.getElementById('vc_osC')?.value || 0, A:+document.getElementById('vc_osA')?.value || 0 };

  const finalOD = reverseVectorChange(origOD, vcOD);
  const finalOS = reverseVectorChange(origOS, vcOS);

  const setIf = (id, val)=> { const el = document.getElementById(id); if(el) el.textContent = val; };
  setIf('od_vcFinalS', roundQuarter(finalOD.S));
  setIf('od_vcFinalC', roundQuarter(finalOD.C));
setIf('od_vcFinalA', fmtAxis(finalOD.A));

  setIf('os_vcFinalS', roundQuarter(finalOS.S));
  setIf('os_vcFinalC', roundQuarter(finalOS.C));
setIf('os_vcFinalA', fmtAxis(finalOS.A));

  const bestVCCross = chooseBestDiff(calcBackwardsLens(vcOS, vcOD), calcBackwardsLens(vcOD, vcOS));
  const bestVCCrossPlus = minusToPlus(bestVCCross);
  setIf('vc_crossS', roundQuarter(bestVCCrossPlus.S));
  setIf('vc_crossC', roundQuarter(bestVCCrossPlus.C));
setIf('vc_crossA', fmtAxis(bestVCCrossPlus.A));

  updateCrossedLens();
}



/* ===== Listeners attach after DOM ready ===== */
window.addEventListener("DOMContentLoaded", ()=>{
  // attach vector listeners (if elements exist)
  ['vc_odS','vc_odC','vc_odA','vc_osS','vc_osC','vc_osA'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.addEventListener('input', updateFinalFromVector);
  });

  // input list for general updates
  document.querySelectorAll("input").forEach(i=>{
    i.addEventListener('input', updateCrossedLens);
    // keep sphere/cyl input coloring (existing behavior)
    const id = i.id;
    const colorInputs = ['od_origS','od_origC','os_origS','os_origC','od_finalS','od_finalC','os_finalS','os_finalC','vc_odS','vc_odC','vc_osS','vc_osC',      'vd_odS','vd_odC','vd_osS','vd_osC'   // added vector defect
];
    if(colorInputs.includes(id)){
      const colorUpdate = ()=> {
        const val = parseFloat(i.value);
        if (!isNaN(val)) i.style.color = (val > 0 ? "green" : (val < 0 ? "red" : "black"));
        else i.style.color = "black";
      };
      i.addEventListener('input', colorUpdate);
      i.addEventListener('blur', ()=>{ const val = parseFloat(i.value); if(!isNaN(val)) i.value = (Math.round(val / 0.25) * 0.25).toFixed(2); colorUpdate(); });
      colorUpdate();
    }
  });

  // initial run
  updateCrossedLens();



});

function copyVD_OD() {
  document.getElementById("vc_odS").value = Number(document.getElementById("vd_out_odS").textContent);
  document.getElementById("vc_odC").value = Number(document.getElementById("vd_out_odC").textContent);
  document.getElementById("vc_odA").value = Number(document.getElementById("vd_out_odA").textContent);
  updateFinalFromVector();
}

function copyVD_OS() {
  document.getElementById("vc_osS").value = Number(document.getElementById("vd_out_osS").textContent);
  document.getElementById("vc_osC").value = Number(document.getElementById("vd_out_osC").textContent);
  document.getElementById("vc_osA").value = Number(document.getElementById("vd_out_osA").textContent);
  updateFinalFromVector();
}

</script>


















<script>
(function(){
  // small helpers (safe, unique names)
  function _parseSpanNumber(txt){
    if(!txt && txt !== 0) return NaN;
    // remove any non-number except - and .
    const cleaned = String(txt).replace(/\+/g,'').replace(/[^\d\.\-]/g,'').trim();
    return cleaned === '' ? NaN : parseFloat(cleaned);
  }

  function _fmtPlus(n){
    if (isNaN(n)) return "-";
    return (n > 0 ? "+" : "") + Number(n).toFixed(2);
  }

  // === Copy functions (global for onclick) ===
  window.copyVD_OD = function(){
    const sText = document.getElementById("vd_out_odS")?.textContent || "";
    const cText = document.getElementById("vd_out_odC")?.textContent || "";
    const aText = document.getElementById("vd_out_odA")?.textContent || "";

    const s = _parseSpanNumber(sText);
    const c = _parseSpanNumber(cText);
    const a = _parseSpanNumber(aText);

    if(!isNaN(s) && document.getElementById("vc_odS")) document.getElementById("vc_odS").value = s.toFixed(2);
    if(!isNaN(c) && document.getElementById("vc_odC")) document.getElementById("vc_odC").value = c.toFixed(2);
    if(!isNaN(a) && document.getElementById("vc_odA")) document.getElementById("vc_odA").value = (isNaN(a)?'':a);

    if(typeof updateFinalFromVector === "function") updateFinalFromVector();
  };

  window.copyVD_OS = function(){
    const sText = document.getElementById("vd_out_osS")?.textContent || "";
    const cText = document.getElementById("vd_out_osC")?.textContent || "";
    const aText = document.getElementById("vd_out_osA")?.textContent || "";

    const s = _parseSpanNumber(sText);
    const c = _parseSpanNumber(cText);
    const a = _parseSpanNumber(aText);

    if(!isNaN(s) && document.getElementById("vc_osS")) document.getElementById("vc_osS").value = s.toFixed(2);
    if(!isNaN(c) && document.getElementById("vc_osC")) document.getElementById("vc_osC").value = c.toFixed(2);
    if(!isNaN(a) && document.getElementById("vc_osA")) document.getElementById("vc_osA").value = (isNaN(a)?'':a);

    if(typeof updateFinalFromVector === "function") updateFinalFromVector();
  };

  // === Combined display updaters ===
  function updateCombinedVC(){
    const odS = document.getElementById("od_vcFinalS")?.textContent || "-";
    const odC = document.getElementById("od_vcFinalC")?.textContent || "-";
    const odA = document.getElementById("od_vcFinalA")?.textContent || "-";
    const osS = document.getElementById("os_vcFinalS")?.textContent || "-";
    const osC = document.getElementById("os_vcFinalC")?.textContent || "-";
    const osA = document.getElementById("os_vcFinalA")?.textContent || "-";

    const odCombEl = document.getElementById("od_vcCombined");
    const osCombEl = document.getElementById("os_vcCombined");
    if(odCombEl) odCombEl.textContent = `${odS} / ${odC} × ${odA}`;
    if(osCombEl) osCombEl.textContent = `${osS} / ${osC} × ${osA}`;
  }

function fmtPlus(v){
  const n = Number(v);
  if(isNaN(n)) return "-";
  return (n > 0 ? "+" : "") + n.toFixed(2);
}

function fmtAxis(a){
  const n = Number(a);
  if(isNaN(n)) return "-";
  return Math.round(n) % 180;
}

function updateCombinedOriginal(){
  const odS = document.getElementById("od_origS")?.value;
  const odC = document.getElementById("od_origC")?.value;
  const odA = document.getElementById("od_origA")?.value;

  const osS = document.getElementById("os_origS")?.value;
  const osC = document.getElementById("os_origC")?.value;
  const osA = document.getElementById("os_origA")?.value;

  const odEl = document.getElementById("od_origCombined");
  const osEl = document.getElementById("os_origCombined");

  if(odEl) odEl.textContent = `${fmtPlus(odS)} / ${fmtPlus(odC)} × ${fmtAxis(odA)}`;
  if(osEl) osEl.textContent = `${fmtPlus(osS)} / ${fmtPlus(osC)} × ${fmtAxis(osA)}`;
}

// auto-update when inputs change
["od_origS","od_origC","od_origA","os_origS","os_origC","os_origA"].forEach(id=>{
  const el = document.getElementById(id);
  if(el) el.addEventListener("input", updateCombinedOriginal);
});

// initial run
updateCombinedOriginal();

  function updateCombinedFinal(){
    const odS = document.getElementById("od_finalS")?.value;
    const odC = document.getElementById("od_finalC")?.value;
    const odA = document.getElementById("od_finalA")?.value;
    const osS = document.getElementById("os_finalS")?.value;
    const osC = document.getElementById("os_finalC")?.value;
    const osA = document.getElementById("os_finalA")?.value;

    const odCombEl = document.getElementById("od_finalCombined");
    const osCombEl = document.getElementById("os_finalCombined");

    if(odCombEl) odCombEl.textContent = `${_fmtPlus(Number(odS))} / ${_fmtPlus(Number(odC))} × ${odA || "-"}`;
    if(osCombEl) osCombEl.textContent = `${_fmtPlus(Number(osS))} / ${_fmtPlus(Number(osC))} × ${osA || "-"}`;
  }

  // === Observe updates to vcFinal spans (they are updated by your code) ===
  function _observeIfExists(selectorList, cb){
    selectorList.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      const mo = new MutationObserver(cb);
      mo.observe(el, { childList: true, characterData: true, subtree: true });
    });
  }

  // Attach when DOM ready
  window.addEventListener("DOMContentLoaded", ()=>{
    // observe vcFinal spans so combined VC updates when updateFinalFromVector writes to them
    _observeIfExists(["od_vcFinalS","od_vcFinalC","od_vcFinalA","os_vcFinalS","os_vcFinalC","os_vcFinalA"], updateCombinedVC);
    // initial run
    updateCombinedVC();

    // attach listeners to manual final inputs so combined final updates immediately
    ["od_finalS","od_finalC","od_finalA","os_finalS","os_finalC","os_finalA"].forEach(id=>{
      const el = document.getElementById(id);
      if(el) el.addEventListener("input", updateCombinedFinal);
    });
    updateCombinedFinal();

    // also observe vd_out spans if they exist — keep them normalized (no destructive edits)
    // (This does not change original behaviour; only ensures numbers are parseable when copying)
    _observeIfExists(["vd_out_odS","vd_out_odC","vd_out_odA","vd_out_osS","vd_out_osC","vd_out_osA"], function(){
      // noop: observation kept in place to ensure future expansions possible; we call nothing here
    });
  });

  // Expose safe helpers for debugging if needed
  window._vdHelpers = { parseSpanNumber: _parseSpanNumber, fmtPlus: _fmtPlus, updateCombinedVC, updateCombinedFinal };

})();
</script>


<!-- your existing HTML content -->

<script>
// === Original Prism Calculation ===
function updateOriginalPrism() {
  const od = {
    S: Number(document.getElementById('od_origS').value) || 0,
    C: Number(document.getElementById('od_origC').value) || 0,
    A: Number(document.getElementById('od_origA').value) || 0
  };
  const os = {
    S: Number(document.getElementById('os_origS').value) || 0,
    C: Number(document.getElementById('os_origC').value) || 0,
    A: Number(document.getElementById('os_origA').value) || 0
  };

  const M_od = od.S + od.C/2;
  const A_od = od.A * Math.PI/180;
  const J0_od = -od.C/2 * Math.cos(2*A_od);
  const J45_od = -od.C/2 * Math.sin(2*A_od);

  const M_os = os.S + os.C/2;
  const A_os = os.A * Math.PI/180;
  const J0_os = -os.C/2 * Math.cos(2*A_os);
  const J45_os = -os.C/2 * Math.sin(2*A_os);

  const dec = 12/10; // example factor

  const prismH = Math.abs((M_od - M_os + J0_od - J0_os) );
  const prismV = Math.abs((M_od - M_os - (J0_od - J0_os)) );
  const prismD = Math.max(Math.abs(M_od - M_os + J45_od - J45_os), Math.abs(M_od - M_os - (J45_od - J45_os))) ;

  document.getElementById('origCrossS').textContent = prismH.toFixed(2);
  document.getElementById('origCrossC').textContent = prismV.toFixed(2);
  document.getElementById('origCrossA').textContent = prismD.toFixed(2);
}

// attach listeners
['od_origS','od_origC','od_origA','os_origS','os_origC','os_origA'].forEach(id=>{
  const el = document.getElementById(id);
  if(el) el.addEventListener('input', updateOriginalPrism);
});

// initial run
updateOriginalPrism();
</script>

<script>
document.getElementById("toggleMask1").addEventListener("click", function() {
  document.querySelectorAll(".mask1").forEach(row => {
    row.classList.toggle("hidden-row");
  });
});

document.getElementById("toggleMask2").addEventListener("click", function() {
  document.querySelectorAll(".mask2").forEach(row => {
    row.classList.toggle("hidden-row");
  });
});

</script>





</body>
</html>





